# AWS S3 사용 설명서



## 1. 버킷 생성

- AWS 접속

![image-20210204215259333](%EC%9D%B4%EA%B0%95%EB%A6%BC.assets/image-20210204215259333.png)



- 로그인

![image-20210204215441976](%EC%9D%B4%EA%B0%95%EB%A6%BC.assets/image-20210204215441976.png)



- 스토리지 > **S3** 클릭

![image-20210204215350490](%EC%9D%B4%EA%B0%95%EB%A6%BC.assets/image-20210204215350490.png)



- 네비게이션바 아래 왼쪽 > `버킷 만들기` 클릭

![image-20210204215545200](%EC%9D%B4%EA%B0%95%EB%A6%BC.assets/image-20210204215545200.png)



- 버킷 이름 입력 (중복 불가) > 리전 선택 (사용자와 가까울수록 고속) > 퍼블릭 엑세스 차단을 위한 버킷 설정 (일단 외부와 통신하기 위해 **모든 퍼블릭 엑세스 차단**의 체크를 해제, 선택은 자신의 몫으로 외부의 공격자에 대한 보호 불가, 적절한 퍼블릭 엑세스 차단 활성화 추천, 차후에 S3 생성 후 권한에서 설정 변경 가능) > 스크롤 최하단에 `버킷 만들기` 클릭

![image-20210204220437454](%EC%9D%B4%EA%B0%95%EB%A6%BC.assets/image-20210204220437454.png)



## 2. access key ID, secret access key 발급

```
https://keichee.tistory.com/298
https://www.44bits.io/ko/post/publishing_and_managing_aws_user_access_key
```



- 네비게이션바 > `🔔` 버튼 옆 > 자신의 계정 클릭 > 드롭다운 > **내 보안 자격 증명** 클릭

![image-20210204215559934](%EC%9D%B4%EA%B0%95%EB%A6%BC.assets/image-20210204215559934.png)



- 왼쪽 사이드바 > 대시보드 > 엑세스 관리 > **사용자** 클릭

![image-20210204215622805](%EC%9D%B4%EA%B0%95%EB%A6%BC.assets/image-20210204215622805.png)



- 위쪽 헤더 > `사용자 추가` 버튼 클릭

![image-20210204215644058](%EC%9D%B4%EA%B0%95%EB%A6%BC.assets/image-20210204215644058.png)



- 사용자 이름 : 이름 입력 (중복 허용) > 엑세스 유형 : **프로그래밍 엑세스** 체크박스 클릭 > 하단에 `다음:권한` 버튼 클릭

![image-20210204215711394](%EC%9D%B4%EA%B0%95%EB%A6%BC.assets/image-20210204215711394.png)



- 권한 설정 : 3번째인 `기존 정책 직접 연결` 클릭 > 🔎검색창에 **S3** 입력 > 결과창에 나온 정책 중 `AmazonS3FullAccess` 체크박스 클릭 > 하단에 `다음:태그` 클릭

![image-20210204221101045](%EC%9D%B4%EA%B0%95%EB%A6%BC.assets/image-20210204221101045.png)



- 이번 페이지는 넘어간다(모르는 내용) > 하단에 `다음:검토` 클릭

![image-20210204221554482](%EC%9D%B4%EA%B0%95%EB%A6%BC.assets/image-20210204221554482.png)



- 자신의 선택과 동일한지 내용 확인 후 > 하단에 `다음:검토` 클릭

![image-20210204221642102](%EC%9D%B4%EA%B0%95%EB%A6%BC.assets/image-20210204221642102.png)



- access key ID, secret access key 발급 완료 > secret access key는 **표시**를 눌려야 보인다. > 이것을 공개적으로 git에 올리면 안된다. > 때문에 application.properities에서도 이용 후 git.ignore에 추가하여 공개되는 것을 맊는다. (하지만 탐프로젝트여서 맊을 수가 없어서 고민이 된다..)

![image-20210204221748154](%EC%9D%B4%EA%B0%95%EB%A6%BC.assets/image-20210204221748154.png)



## 3. S3 활용

- porm.xml

```xml
...

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-aws-autoconfigure</artifactId>
    <version>2.2.1.RELEASE</version>
</dependency>

...
```



- application.properties

```
cloud.aws.credentials.accessKey=자신의accessKey
cloud.aws.credentials.secretKey=자신의secretKey
cloud.aws.s3.bucket=자신의bucket명
cloud.aws.region.static=자신의bucket리전
cloud.aws.stack.auto=false # 이것은 왜하는지 기억이 안나는데 다들 해서 했음. 안해도 되지만 책임은 안진다.
```



- S3Service.java

new Data().getTime()을 String으로 변환하여 파일의 이름으로 사용하였다. 왜냐하면 각 이미지 파일마다 고유의 식별자가 필요했기 때문이다. (User의 ID나 Email을 파일 이름으로 사용해서 저장하는 방법 추가도 고려 중)

파일의 고유의 이름을 사용하면 파일의 이름이 같으면 충돌이 발생할 것 같아 제일 먼저 기각, User의 nickname이나 id 같은 고유의 값을 사용하려고 했는데 한 사람이 여러 개의 사진을 등록할 수 있으므로 기각, ... 



구글에 여러 사람의 코드를 참고 했는데, 주로 배달의 민족 개발자 분의 것을 차용했다. 

하지만 그분의 소스에서 ajax를 통해 Multipartfile 형태로 이미지 데이터를 넘기는데 

axios로 Multipartfile 형태로 넘기기 위해서는 header 에 Context-type을 선연해야 하는데 다른 데이터들을 json으로 보내야하기 때문에 삼질을 좀 했다... (여기서 대부분의 시간을 허비)

처음에는 통신을 2개 따로 보낼까 했는데 빈 모 개발자가 만들어둔 소스를 이용해서 json(string) 형태로 file을 변환해서 전송한 것을 byte로 파싱해서 파일을 만드는 부분을 알차게 사용했다. (고맙다.. ㅂㅈㅎ 개발자...)



아래의 service를 사용하면

프로필 이미지를 AWS S3 서버에 올리고,

해당 url을 받아와서,

그 url을 <img :src="url" alt=""\> 이런 식으로 바로 바인딩해서 쓰면

해당 이미지를 볼 수 있다!



자체적으로 개발할 수도 있을 것 같지만 무엇인가 귀찮은 일들이 더욱 생길 것 같아 신뢰성 극강의 외부 서버를 이용하는 것 편하다.

```java
package com.ssafy.ssafying.model.service;

import java.io.File;
import java.io.IOException;

import com.amazonaws.auth.AWSCredentials;
import com.amazonaws.auth.AWSStaticCredentialsProvider;
import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.AmazonS3ClientBuilder;
import com.amazonaws.services.s3.model.CannedAccessControlList;
import com.amazonaws.services.s3.model.PutObjectRequest;
import com.ssafy.ssafying.model.UserDto;

import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;

import java.io.ByteArrayInputStream;
import javax.imageio.ImageIO;
import javax.xml.bind.DatatypeConverter;


@Slf4j
@Service
@NoArgsConstructor
public class S3Service {
    private AmazonS3 s3Client;

    @Value("${cloud.aws.credentials.accessKey}")
    private String accessKey;

    @Value("${cloud.aws.credentials.secretKey}")
    private String secretKey;

    @Value("${cloud.aws.s3.bucket}")
    private String bucket;

    @Value("${cloud.aws.region.static}")
    private String region;

    @PostConstruct
    public void setS3Client() {
        AWSCredentials credentials = new BasicAWSCredentials(this.accessKey, this.secretKey);

        s3Client = AmazonS3ClientBuilder.standard()
                .withCredentials(new AWSStaticCredentialsProvider(credentials))
                .withRegion(this.region)
                .build();
    }

    public String upload(UserDto userDto, String dirName) throws Exception{
        File uploadFile = createNewFile(userDto);
        String uploadImageUrl = putS3(uploadFile, dirName);
        removeNewFile(uploadFile);
        return uploadImageUrl;
    }

    private File createNewFile(UserDto userDto) throws Exception{
        String url = System.getProperty("user.dir") + userDto.getNickname() + ".png";

        File uploadFile = new File(url);
        String jsonData = userDto.getProfileImage();
        byte[] BinaryData = DatatypeConverter.parseBase64Binary(jsonData.substring(jsonData.indexOf(",") + 1));
        ImageIO.write(ImageIO.read(new ByteArrayInputStream(BinaryData)), "png", uploadFile);
        
        return uploadFile;
    }

    private String putS3(File uploadFile, String dirName) {
        s3Client.putObject(new PutObjectRequest(bucket, dirName, uploadFile)
                .withCannedAcl(CannedAccessControlList.PublicRead));
        return s3Client.getUrl(bucket, dirName).toString();
    }

    private void removeNewFile(File targetFile) {
        if (targetFile.delete()) {
            log.info("파일이 삭제되었습니다.");
        } else {
            log.info("파일이 삭제되지 못했습니다.");
        }
    }
}
```



- AWS S3 버킷에 업로드된 사진 2장

![image-20210204223142746](%EC%9D%B4%EA%B0%95%EB%A6%BC.assets/image-20210204223142746.png)



- MySQL DB에 User Table에 등록된 AWS S3에서 할당된 url 주소가 저장되 있는 것을 확인할 수 있다.

![image-20210204223320107](%EC%9D%B4%EA%B0%95%EB%A6%BC.assets/image-20210204223320107.png)



- 참고로 AWS S3 비용 정책을 자세히는 몰라서 최대한 적은 크기의 이미지 파일을 사용해 주기를 권장한다. 그리고 이를 위해 차후에 사용자들에게도 적용하기 위해 Frontend나 Backend에서 파일의 크기를 검사하여 일정 이상의 크기는 거부하는 로직을 구현해야 할 것이다. (30KB도 충분히 식별가능하다...)